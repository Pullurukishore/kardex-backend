import { Response } from 'express';
import { format } from 'date-fns';

export interface ColumnDefinition {
  key: string;
  header: string;
  format?: (value: any) => string;
}

// Helper function to escape CSV values
function escapeCsvValue(value: any): string {
  if (value === null || value === undefined) return '';
  
  // Convert to string
  const str = String(value);
  
  // Escape quotes and wrap in quotes if needed
  if (str.includes('"') || str.includes(',') || str.includes('\n') || str.includes('\r')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  
  return str;
}

// Helper function to format cell values
function formatCellValue(value: any, formatter?: (val: any) => string): string {
  if (formatter) return formatter(value);
  if (value === null || value === undefined) return '';
  if (value instanceof Date) return format(value, 'yyyy-MM-dd HH:mm:ss');
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
}

// Main function to generate CSV with enhanced formatting
export const generateCsv = (
  res: Response,
  data: any[],
  columns: ColumnDefinition[],
  title: string,
  filters: { [key: string]: any },
  summaryData?: any
): void => {
  try {
    // Add BOM for Excel compatibility
    let csvContent = '\uFEFF';
    
    // Add title and metadata header
    csvContent += `"${title}"\n`;
    csvContent += `"Generated on: ${new Date().toLocaleString()}"\n`;
    csvContent += `"Date Range: ${new Date(filters.from).toLocaleDateString()} - ${new Date(filters.to).toLocaleDateString()}"\n`;
    
    // Add filter information
    const activeFilters = Object.entries(filters)
      .filter(([key, value]) => !['from', 'to', 'format', 'reportType'].includes(key) && value)
      .map(([key, value]) => `${key.charAt(0).toUpperCase() + key.slice(1)}: ${value}`);
    
    if (activeFilters.length > 0) {
      csvContent += `"Filters: ${activeFilters.join(', ')}"\n`;
    }
    
    csvContent += '\n'; // Empty line
    
    // Add summary section if provided
    if (summaryData && Object.keys(summaryData).length > 0) {
      csvContent += '"EXECUTIVE SUMMARY"\n';
      for (const [key, value] of Object.entries(summaryData)) {
        const formattedKey = key.split(/(?=[A-Z])/).join(' ').replace(/^./, str => str.toUpperCase());
        csvContent += `"${formattedKey}","${formatCellValue(value)}"\n`;
      }
      csvContent += '\n'; // Empty line
    }
    
    // Add data section header
    csvContent += '"DETAILED DATA"\n';
    
    // Create CSV header row
    const headers = columns.map(col => escapeCsvValue(col.header));
    csvContent += headers.join(',') + '\n';
    
    // Add data rows with enhanced formatting
    for (const item of data) {
      const row = columns.map(col => {
        // Get the value using the column key (support nested properties)
        const value = col.key.split('.').reduce((obj, key) => {
          if (obj && typeof obj === 'object' && key in obj) {
            return obj[key];
          }
          return '';
        }, item);
        
        // Format the value
        const formattedValue = formatCellValue(value, col.format);
        return escapeCsvValue(formattedValue);
      });
      
      csvContent += row.join(',') + '\n';
    }
    
    // Add footer with record count
    csvContent += '\n';
    csvContent += `"Total Records: ${data.length}"\n`;
    csvContent += `"Report Generated by KardexCare Service Management System"\n`;
    
    // Set response headers with enhanced filename
    const timestamp = format(new Date(), 'yyyy-MM-dd-HHmm');
    const filename = `${title.toLowerCase().replace(/\s+/g, '-')}-${timestamp}.csv`;
    
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Pragma', 'no-cache');
    
    // Send the CSV response
    res.send(csvContent);
    
  } catch (error) {
    console.error('Error generating CSV:', error);
    res.status(500).json({ error: 'Failed to generate CSV report' });
  }
};

// Enhanced column definitions for different report types
export const getCsvColumns = (reportType: string): ColumnDefinition[] => {
  switch (reportType) {
    case 'ticket-summary':
      return [
        { key: 'id', header: 'Ticket ID' },
        { key: 'title', header: 'Title' },
        { key: 'status', header: 'Status' },
        { key: 'priority', header: 'Priority' },
        { key: 'customer.companyName', header: 'Customer' },
        { key: 'assignedTo.name', header: 'Assigned To' },
        { key: 'zone.name', header: 'Service Zone' },
        { key: 'createdAt', header: 'Created Date', format: (date) => format(new Date(date), 'yyyy-MM-dd HH:mm') },
        { key: 'updatedAt', header: 'Last Updated', format: (date) => format(new Date(date), 'yyyy-MM-dd HH:mm') }
      ];
    
    case 'customer-satisfaction':
      return [
        { key: 'id', header: 'Feedback ID' },
        { key: 'rating', header: 'Rating (1-5)' },
        { key: 'comment', header: 'Customer Comments' },
        { key: 'ticket.id', header: 'Ticket ID' },
        { key: 'ticket.customer.companyName', header: 'Customer' },
        { key: 'submittedAt', header: 'Feedback Date', format: (date) => format(new Date(date), 'yyyy-MM-dd HH:mm') }
      ];
    
    case 'industrial-data':
      return [
        { key: 'machineId', header: 'Machine ID' },
        { key: 'model', header: 'Machine Model' },
        { key: 'serialNo', header: 'Serial Number' },
        { key: 'customer', header: 'Customer' },
        { key: 'zone', header: 'Service Zone' },
        { key: 'ticketTitle', header: 'Issue Description' },
        { key: 'status', header: 'Status' },
        { key: 'priority', header: 'Priority' },
        { key: 'downtimeMinutes', header: 'Downtime (Minutes)' },
        { key: 'assignedTo', header: 'Assigned Technician' },
        { key: 'createdAt', header: 'Issue Reported', format: (date) => format(new Date(date), 'yyyy-MM-dd HH:mm') }
      ];
    
    case 'zone-performance':
      return [
        { key: 'zoneName', header: 'Service Zone' },
        { key: 'totalTickets', header: 'Total Tickets' },
        { key: 'resolvedTickets', header: 'Resolved Tickets' },
        { key: 'openTickets', header: 'Open Tickets' },
        { key: 'resolutionRate', header: 'Resolution Rate (%)' },
        { key: 'averageResolutionTime', header: 'Avg Resolution Time (Minutes)' },
        { key: 'servicePersons', header: 'Service Personnel Count' },
        { key: 'customerCount', header: 'Customer Count' }
      ];
    
    case 'agent-productivity':
      return [
        { key: 'agentName', header: 'Agent Name' },
        { key: 'email', header: 'Email' },
        { key: 'totalTickets', header: 'Total Tickets' },
        { key: 'resolvedTickets', header: 'Resolved Tickets' },
        { key: 'openTickets', header: 'Open Tickets' },
        { key: 'resolutionRate', header: 'Resolution Rate (%)' },
        { key: 'averageResolutionTime', header: 'Avg Resolution Time (Minutes)' },
        { key: 'zones', header: 'Service Zones', format: (zones) => Array.isArray(zones) ? zones.join(', ') : zones }
      ];
    
    case 'executive-summary':
      return [
        { key: 'metric', header: 'Key Performance Indicator' },
        { key: 'value', header: 'Current Value' },
        { key: 'trend', header: 'Trend' },
        { key: 'target', header: 'Target' },
        { key: 'status', header: 'Status' }
      ];
    
    default:
      return getColumnsForReport(reportType).map(({ key, header, format }) => ({
        key,
        header,
        format
      }));
  }
};

// Re-export the getColumnsForReport from pdfGenerator
import { getColumnsForReport } from './pdfGenerator';
export { getColumnsForReport };

// Enhanced helper function to get nested object values
function getNestedValue(obj: any, path: string): any {
  return path.split('.').reduce((current, key) => {
    if (current && typeof current === 'object' && key in current) {
      return current[key];
    }
    return '';
  }, obj);
}
